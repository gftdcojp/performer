# Performer Framework Complete Guide

BPMN + Actor + Neo4j Web Framework (Next.js Type Conventions × Remix Boundaries × Effect Execution)

## Table of Contents

1. [Overview and Features](#overview-and-features)
2. [Architecture Overview](#architecture-overview)
3. [Quick Start](#quick-start)
4. [Project Structure and Naming Conventions](#project-structure-and-naming-conventions)
5. [BPMN Process Development](#bpmn-process-development)
6. [Actor System](#actor-system)
7. [Data Access (Neo4j)](#data-access-neo4j)
8. [Authentication & Authorization](#authentication--authorization)
9. [Monitoring & Observability](#monitoring--observability)
10. [Deployment](#deployment)
11. [Best Practices](#best-practices)
12. [Troubleshooting](#troubleshooting)

## 🎯 Overview and Features

Performer is a full-stack web framework that integrates Business Process Management (BPMN), actor systems, and Neo4j databases. It provides a unique architecture that combines Next.js file-based routing, Remix's loader/action patterns, and Effect's functional programming.

### 🚀 Key Features

- **BPMN Control Flow**: Visually define and execute business processes
- **Actor System**: Distributed execution of service tasks with fault tolerance
- **Neo4j Integration**: Flexible data management with graph databases
- **Type Safety**: End-to-end type safety with TypeScript + Zod
- **Monorepo**: Efficient development with pnpm + Turborepo
- **Human-in-the-Loop**: Form operations with Camunda FormJS integration

## 🏗️ Architecture Overview

### Technology Stack

| Layer | Technology | Description |
|----|------|------|
| Routing | File-based Router | Next.js style `app/**/page.client.tsx` |
| Boundary Management | Remix Actions | Server/client boundary with loader/action patterns |
| Execution Foundation | Effect | Functional programming and error handling |
| Process Engine | BPMN SDK | Control flow definition and execution |
| Actor | Effect Actor | Distributed execution of service tasks |
| Data | Neo4j + Neogma | Type-safe Cypher queries |
| UI | React + Tailwind | Modern user interface |
| Authentication | Auth0 | Access control with RBAC/ABAC |
| Monitoring | OpenTelemetry + Sentry | Distributed tracing and error monitoring |
| Forms | Camunda FormJS | Human-in-the-loop forms |

### Project Structure

```
performer/
├── packages/
│   ├── router/          # Next.js style file-based router
│   ├── actions/         # Remix loader/action + Auth0 guards
│   ├── process/         # BPMN SDK wrapper
│   ├── actor/           # Effect-based actor system
│   ├── data/            # Neo4j + Neogma adapter
│   ├── dev-server/      # Vite SSR development server
│   ├── contracts/       # ts-rest + Zod schemas
│   ├── observability/   # OpenTelemetry + Sentry
│   └── cli/             # Development tools CLI
├── apps/
│   └── examples/demo-app/  # Sample application
├── tools/
│   └── turbo.json       # Build optimization settings
└── docs/                # Documentation
```

## 🚀 Quick Start

### Prerequisites

- Node.js 18+
- pnpm 8+
- Neo4j 5.0+
- Auth0 account

### Installation

```bash
# Clone repository
git clone https://github.com/gftdcojp/performer.git
cd performer

# Install dependencies
pnpm install

# Start development server
pnpm dev
```

### Configuration

#### 1. Neo4j Setup

```bash
# Start Neo4j
docker run -d -p 7474:7474 -p 7687:7687 \
  -e NEO4J_AUTH=neo4j/password \
  neo4j:5.0
```

#### 2. Auth0 Setup

```typescript
// packages/actions/src/config.ts
export const auth0Config = {
  domain: 'your-domain.auth0.com',
  clientID: 'your-client-id',
  audience: 'your-api-identifier'
}
```

#### 3. Environment Variables

```bash
cp .env.example .env
# Edit .env file
```

## 📁 Project Structure and Naming Conventions

### File Naming Conventions

| Type | Naming Convention | Example |
|------|------------------|---------|
| Page | `page.client.tsx` | `app/order/page.client.tsx` |
| Server Loader | `loader.server.ts` | `app/order/loader.server.ts` |
| Server Actions | `actions.server.ts` | `app/order/actions.server.ts` |
| BPMN Process | `process.flow.ts` | `app/order/process.flow.ts` |
| Data Model | `model.ts` | `app/order/model.ts` |

### Directory Structure

```
app/
├── [feature]/
│   ├── page.client.tsx          # UI components
│   ├── loader.server.ts         # Data loading
│   ├── actions.server.ts        # Data writing
│   ├── process.flow.ts          # BPMN process definition
│   └── model.ts                 # Data model
```

## 🔄 BPMN Process Development

### Process Definition

```typescript
// app/order/process.flow.ts
import { flow } from "@pkg/process";

export const orderProcess = flow("OrderProcess", (p) => {
  p.startEvent("OrderReceived")
    .serviceTask("ValidateOrder")
    .exclusiveGateway("AmountCheck")
      .when("low", { expr: "${vars.amount <= 1000}" })
        .serviceTask("AutoApprove")
        .moveTo("Payment")
      .otherwise()
        .userTask("ManagerApproval")
        .moveTo("Payment")
    .serviceTask("Payment")
    .endEvent("Completed");
});
```

### User Tasks (Human-in-the-Loop)

```typescript
// app/order/process.flow.ts
import { flow } from "@pkg/process";

export const approvalProcess = flow("ApprovalProcess", (p) => {
  p.startEvent("ApprovalRequested")
    .userTask("ManagerReview", {
      formSchema: {
        type: "default",
        components: [
          {
            type: "number",
            id: "amount",
            label: "Approval Amount",
            validate: { required: true }
          },
          {
            type: "select",
            id: "decision",
            label: "Approval Decision",
            values: [
              { label: "Approve", value: "approved" },
              { label: "Reject", value: "rejected" }
            ]
          },
          {
            type: "textarea",
            id: "comments",
            label: "Comments"
          }
        ]
      }
    })
    .exclusiveGateway("DecisionCheck")
      .when("approved", { expr: "${vars.decision == 'approved'}" })
        .serviceTask("ProcessApproval")
        .endEvent("Approved")
      .otherwise()
        .serviceTask("SendRejection")
        .endEvent("Rejected");
});
```

### Process Execution

```typescript
// app/order/actions.server.ts
"use server";

import { startProcess, completeTask } from "@pkg/process";
import { withTx } from "@pkg/data/tx";

export async function startOrder(input: OrderInput) {
  return withTx(async (tx) => {
    const processInstance = await startProcess({
      processId: "OrderProcess",
      businessKey: input.businessKey,
      variables: {
        amount: input.amount,
        customerId: input.customerId
      }
    }, { tx });

    return { processInstanceId: processInstance.id };
  });
}

export async function completeApproval(input: ApprovalInput) {
  return withTx(async (tx) => {
    await completeTask({
      taskId: input.taskId,
      variables: {
        decision: input.decision,
        comments: input.comments
      }
    }, { tx });

    return { ok: true };
  });
}
```

## 🎭 Actor System

### Actor Definition

```typescript
// packages/actor/src/order-actor.ts
import { Actor, actor } from "@pkg/actor";

interface OrderActorState {
  orderId: string;
  status: "pending" | "processing" | "completed";
}

export const orderActor = actor<OrderActorState>("OrderActor", {
  initialState: (orderId: string) => ({
    orderId,
    status: "pending"
  }),

  actions: {
    startProcessing: (state) => ({
      ...state,
      status: "processing"
    }),

    complete: (state) => ({
      ...state,
      status: "completed"
    })
  },

  effects: {
    onStartProcessing: async (state, ctx) => {
      // External service calls, etc.
      await ctx.callExternalService("process-order", {
        orderId: state.orderId
      });
    }
  }
});
```

### Actor Usage

```typescript
// app/order/actions.server.ts
import { spawnActor, sendMessage } from "@pkg/actor";

export async function processOrder(orderId: string) {
  const actorRef = await spawnActor(orderActor, orderId);

  // Send message to actor
  await sendMessage(actorRef, "startProcessing");

  return { actorId: actorRef.id };
}
```

## 🗄️ Data Access (Neo4j)

### Model Definition

```typescript
// app/order/model.ts
import { Model, model } from "@pkg/data";

export interface Order {
  id: string;
  businessKey: string;
  customerId: string;
  amount: number;
  status: "pending" | "approved" | "rejected";
  createdAt: Date;
}

export const OrderModel = model("Order", {
  id: { type: "string", primary: true },
  businessKey: { type: "string", unique: true },
  customerId: { type: "string", required: true },
  amount: { type: "number", required: true },
  status: { type: "string", required: true },
  createdAt: { type: "date", default: () => new Date() }
});
```

### Query Execution

```typescript
// app/order/loader.server.ts
"use server";

import { q } from "@pkg/data/effect-cypher";
import { OrderModel } from "./model";

export async function loader({ businessKey }: { businessKey: string }) {
  return q(OrderModel)
    .matchNode("o", { businessKey })
    .ret("o")
    .one();
}
```

### Complex Queries

```typescript
// Query with related data
export async function getOrderWithCustomer(orderId: string) {
  return q(OrderModel)
    .matchNode("o", { id: orderId })
    .matchRelationship("o", "BELONGS_TO", "c", "Customer")
    .ret("o", "c")
    .one();
}

// Aggregation query
export async function getOrderStats() {
  return q(OrderModel)
    .matchNode("o")
    .ret("count(o) as totalOrders", "sum(o.amount) as totalAmount")
    .one();
}
```

### Transactions

```typescript
// app/order/actions.server.ts
import { withTx } from "@pkg/data/tx";

export async function createOrder(input: OrderInput) {
  return withTx(async (tx) => {
    // Create order
    const order = await q(OrderModel)
      .create({
        businessKey: input.businessKey,
        customerId: input.customerId,
        amount: input.amount,
        status: "pending"
      })
      .ret("o")
      .one({ tx });

    // Create relationship with customer
    await q()
      .matchNode("o", "Order", { id: order.id })
      .matchNode("c", "Customer", { id: input.customerId })
      .createRelationship("o", "BELONGS_TO", "c")
      .run({ tx });

    return order;
  });
}
```

## 🔐 Authentication & Authorization

### Auth0 Configuration

```typescript
// packages/actions/src/auth.ts
import { initAuth0 } from "@auth0/nextjs-auth0";

export const auth0 = initAuth0({
  domain: process.env.AUTH0_DOMAIN!,
  clientId: process.env.AUTH0_CLIENT_ID!,
  clientSecret: process.env.AUTH0_CLIENT_SECRET!,
  audience: process.env.AUTH0_AUDIENCE!
});
```

### Authorization Guards

```typescript
// packages/actions/src/guards.ts
import { auth0 } from "./auth";

export function authorize(permissions: string[]) {
  return async function guard() {
    const session = await auth0.getSession();

    if (!session) {
      throw new Error("Unauthorized");
    }

    // Permission check
    const userPermissions = session.user.permissions || [];
    const hasPermission = permissions.every(p =>
      userPermissions.includes(p)
    );

    if (!hasPermission) {
      throw new Error("Forbidden");
    }

    return { user: session.user };
  };
}
```

### Usage in Actions

```typescript
// app/order/actions.server.ts
import { authorize } from "@pkg/actions/guards";

export async function createOrder(input: OrderInput) {
  const { user } = await authorize(["order:create"]);

  // Create order linked to user
  return withTx(async (tx) => {
    const order = await q(OrderModel)
      .create({
        ...input,
        createdBy: user.id
      })
      .ret("o")
      .one({ tx });

    return order;
  });
}
```

### RBAC/ABAC Policies

```typescript
// packages/actions/src/policies.ts
export const orderPolicies = {
  // RBAC: Role-based
  canCreateOrder: (user: User) =>
    user.roles.includes("order_manager") ||
    user.roles.includes("admin"),

  // ABAC: Attribute-based
  canApproveOrder: (user: User, order: Order) =>
    user.roles.includes("manager") &&
    order.amount <= user.approvalLimit,

  // Organization-based
  canViewOrder: (user: User, order: Order) =>
    user.organizationId === order.organizationId ||
    user.roles.includes("admin")
};
```

## 📊 Monitoring & Observability

### OpenTelemetry Configuration

```typescript
// packages/observability/src/tracing.ts
import { NodeTracerProvider } from "@opentelemetry/sdk-trace-node";
import { registerInstrumentations } from "@opentelemetry/instrumentation";
import { JaegerExporter } from "@opentelemetry/exporter-jaeger";

const provider = new NodeTracerProvider();
const exporter = new JaegerExporter({
  endpoint: process.env.JAEGER_ENDPOINT
});

provider.addSpanProcessor(new BatchSpanProcessor(exporter));
provider.register();

// Auto-instrumentation
registerInstrumentations({
  instrumentations: [
    new HttpInstrumentation(),
    new ExpressInstrumentation(),
    new Neo4jInstrumentation()
  ]
});
```

### Metrics Collection

```typescript
// packages/observability/src/metrics.ts
import { MeterProvider, Meter } from "@opentelemetry/metrics";

export const meter = new MeterProvider().getMeter("performer");

export const orderMetrics = {
  ordersCreated: meter.createCounter("orders_created_total", {
    description: "Total number of orders created"
  }),

  orderProcessingTime: meter.createHistogram("order_processing_duration", {
    description: "Time taken to process orders"
  }),

  activeProcesses: meter.createUpDownCounter("active_processes", {
    description: "Number of currently active processes"
  })
};
```

### Error Monitoring

```typescript
// packages/observability/src/error-monitoring.ts
import * as Sentry from "@sentry/node";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  integrations: [
    new Sentry.Integrations.Http({ tracing: true }),
    new Sentry.Integrations.Neo4j()
  ]
});

export const captureError = (error: Error, context?: any) => {
  Sentry.withScope(scope => {
    if (context) {
      scope.setContext("additional_info", context);
    }
    Sentry.captureException(error);
  });
};
```

### Trace Usage

```typescript
// app/order/actions.server.ts
import { trace } from "@pkg/observability/tracing";

export async function processOrder(input: OrderInput) {
  return trace("processOrder", async (span) => {
    span.setAttribute("order.businessKey", input.businessKey);
    span.setAttribute("order.amount", input.amount);

    try {
      const result = await createOrder(input);
      span.setAttribute("order.id", result.id);
      return result;
    } catch (error) {
      span.recordException(error);
      throw error;
    }
  });
}
```

## 🚀 Deployment

### Docker Build

```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Install dependencies
FROM base AS deps
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile

# Build application
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN pnpm build

# Production image
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production

COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./

EXPOSE 3000
CMD ["pnpm", "start"]
```

### Kubernetes Deployment

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: performer-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: performer
  template:
    metadata:
      labels:
        app: performer
    spec:
      containers:
      - name: performer
        image: performer:latest
        ports:
        - containerPort: 3000
        env:
        - name: NEO4J_URI
          value: "bolt://neo4j-service:7687"
        - name: AUTH0_DOMAIN
          valueFrom:
            secretKeyRef:
              name: auth0-secrets
              key: domain
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
```

### Environment-specific Configuration

```typescript
// config/environments.ts
export const environments = {
  development: {
    neo4j: {
      uri: "bolt://localhost:7687",
      user: "neo4j",
      password: "password"
    },
    auth0: {
      domain: "dev-domain.auth0.com",
      audience: "dev-api"
    }
  },
  staging: {
    neo4j: {
      uri: process.env.NEO4J_URI!,
      user: process.env.NEO4J_USER!,
      password: process.env.NEO4J_PASSWORD!
    },
    auth0: {
      domain: process.env.AUTH0_DOMAIN!,
      audience: process.env.AUTH0_AUDIENCE!
    }
  },
  production: {
    neo4j: {
      uri: process.env.NEO4J_URI!,
      user: process.env.NEO4J_USER!,
      password: process.env.NEO4J_PASSWORD!
    },
    auth0: {
      domain: process.env.AUTH0_DOMAIN!,
      audience: process.env.AUTH0_AUDIENCE!
    }
  }
};
```

## 📋 Best Practices

### 1. Process Design

- **Single Responsibility**: Each process handles one business function
- **Appropriate Granularity**: Keep processes small and reusable
- **Error Handling**: Implement proper error handling at each step

### 2. Data Modeling

- **Graph Thinking**: Design centered on relationships, leveraging Neo4j characteristics
- **Index Utilization**: Create indexes on frequently searched properties
- **Schema Constraints**: Define constraints to maintain data integrity

### 3. Actor Design

- **Message-driven**: Communication between actors via messages
- **Fault Tolerance**: Design so actor failures don't affect the entire system
- **Resource Management**: Properly manage actor lifecycle

### 4. Security

- **Least Privilege**: Grant only necessary permissions
- **Input Validation**: Validate all input data
- **Audit Logging**: Record important operations in logs

### 5. Performance

- **Query Optimization**: Write efficient Cypher queries
- **Caching Strategy**: Implement appropriate caching layers
- **Asynchronous Processing**: Execute heavy processing asynchronously

## 🔧 Troubleshooting

### Common Issues

#### 1. Neo4j Connection Error

```bash
# Test connection
curl http://localhost:7474/

# Check logs
docker logs neo4j-container
```

#### 2. Auth0 Configuration Error

```typescript
// Verify configuration
const auth0 = initAuth0({
  domain: process.env.AUTH0_DOMAIN,
  clientId: process.env.AUTH0_CLIENT_ID,
  clientSecret: process.env.AUTH0_CLIENT_SECRET,
  audience: process.env.AUTH0_AUDIENCE
});

// Debug logging
console.log('Auth0 config:', {
  domain: process.env.AUTH0_DOMAIN,
  clientId: process.env.AUTH0_CLIENT_ID?.substring(0, 10) + '...',
  audience: process.env.AUTH0_AUDIENCE
});
```

#### 3. BPMN Process Execution Error

```typescript
// Check process state
const processInstance = await getProcessInstance(processInstanceId);
console.log('Process state:', processInstance.state);

// Check variables
console.log('Process variables:', processInstance.variables);
```

### Debug Tools

#### Development Logging

```typescript
// packages/observability/src/debug.ts
import { logger } from "./logger";

export const debug = {
  // Detailed process execution logging
  logProcessExecution: (processId: string, variables: any) => {
    logger.info(`Process ${processId} executed`, {
      variables,
      timestamp: new Date().toISOString()
    });
  },

  // Database query logging
  logQuery: (query: string, params: any, duration: number) => {
    logger.debug(`Query executed in ${duration}ms`, {
      query,
      params,
      duration
    });
  },

  // Error tracing
  logError: (error: Error, context: any) => {
    logger.error('Error occurred', {
      error: error.message,
      stack: error.stack,
      context
    });
  }
};
```

#### Test Helpers

```typescript
// Process execution test
export const testProcessExecution = async (processId: string, input: any) => {
  const tracer = await startProcess({
    processId,
    businessKey: `test-${Date.now()}`,
    variables: input
  });

  // Wait for process completion
  await waitForProcessCompletion(tracer.id);

  return tracer;
};

// Database state test
export const testDatabaseState = async (query: string) => {
  const result = await q().raw(query).run();
  console.table(result.records);
  return result;
};
```

### Performance Tuning

#### 1. Query Optimization

```typescript
// Inefficient query
const badQuery = q(OrderModel)
  .matchNode("o")
  .matchRelationship("o", "BELONGS_TO", "c")
  .ret("o", "c")
  .many();

// Optimized query
const goodQuery = q(OrderModel)
  .matchNode("o", { status: "active" }) // Add condition
  .matchRelationship("o", "BELONGS_TO", "c")
  .ret("o", "c")
  .many();
```

#### 2. Index Creation

```cypher
// Create indexes in Neo4j
CREATE INDEX order_business_key FOR (o:Order) ON (o.businessKey);
CREATE INDEX order_status FOR (o:Order) ON (o.status);
CREATE INDEX customer_email FOR (c:Customer) ON (c.email);
```

#### 3. Caching Strategy

```typescript
// Redis caching
import { Redis } from "ioredis";

const redis = new Redis(process.env.REDIS_URL);

export const cache = {
  get: async (key: string) => {
    const data = await redis.get(key);
    return data ? JSON.parse(data) : null;
  },

  set: async (key: string, value: any, ttl = 300) => {
    await redis.setex(key, ttl, JSON.stringify(value));
  },

  invalidate: async (pattern: string) => {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  }
};
```

## 📚 Additional Resources

- [Official Documentation](docs/)
- [API Reference](docs/api-reference.md)
- [Sample Applications](apps/examples/demo-app/)
- [Community](https://github.com/gftdcojp/performer/discussions)

---

This guide explains the comprehensive usage of the Performer Framework. For actual development, refer to the detailed API documentation of each package.
